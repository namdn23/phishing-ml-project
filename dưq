import pandas as pd
import socket
import ssl
import concurrent.futures
import time
from urllib.parse import urlparse
from datetime import datetime
import sys

# Th∆∞ vi·ªán x·ª≠ l√Ω ch·ª©ng ch·ªâ "l·ªèm"
try:
    import OpenSSL.crypto
except ImportError:
    print("‚ùå L·ªói: B·∫°n ch∆∞a c√†i pyopenssl. H√£y ch·∫°y: pip install pyopenssl")
    sys.exit(1)

# --- C·∫§U H√åNH ---
INPUT_FILE = 'dataset_final_train.csv'       
OUTPUT_FILE = 'dataset_final_train_fixed.csv' 
MAX_WORKERS = 20  # Gi·ªØ th·∫•p ƒë·ªÉ tr√°nh b·ªã ch·∫∑n
TIMEOUT_SOCKET = 5 # 5s l√† ƒë·ªß

# --- H√ÄM L·∫§Y SSL C·∫¢I TI·∫æN (CH·∫æ ƒê·ªò B·∫§T CH·∫§P) ---
def get_ssl_info_robust(url):
    try:
        # 1. X·ª≠ l√Ω URL
        url = str(url).strip()
        if not url.startswith(('http://', 'https://')):
            url = 'https://' + url 
        
        parsed = urlparse(url)
        domain = parsed.netloc.split(':')[0] # B·ªè port
        
        if not domain: return -1, -1, 0, "Unknown"

        # 2. T·∫°o Context: T·∫ÆT H·∫æT B·∫¢O M·∫¨T [QUAN TR·ªåNG]
        ctx = ssl.create_default_context()
        ctx.check_hostname = False        # Kh√¥ng check t√™n mi·ªÅn
        ctx.verify_mode = ssl.CERT_NONE   # Kh√¥ng check ch·ª©ng ch·ªâ x·ªãn/d·ªèm
        
        # 3. K·∫øt n·ªëi Socket
        with socket.create_connection((domain, 443), timeout=TIMEOUT_SOCKET) as sock:
            with ctx.wrap_socket(sock, server_hostname=domain) as ssock:
                # L·∫•y ch·ª©ng ch·ªâ d·∫°ng nh·ªã ph√¢n (Binary)
                cert_bin = ssock.getpeercert(binary_form=True)
                
                # 4. Gi·∫£i m√£ b·∫±ng PyOpenSSL (V√¨ cert l·ªói Python th∆∞·ªùng kh√¥ng ƒë·ªçc ƒë∆∞·ª£c)
                x509 = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_ASN1, cert_bin)
                
                # L·∫•y ng√†y th√°ng (Format c·ªßa OpenSSL: YYYYMMDDhhmmssZ)
                not_before_str = x509.get_notBefore().decode('ascii')
                not_after_str = x509.get_notAfter().decode('ascii')
                
                not_before = datetime.strptime(not_before_str, '%Y%m%d%H%M%SZ')
                not_after = datetime.strptime(not_after_str, '%Y%m%d%H%M%SZ')
                
                cert_age = (datetime.now() - not_before).days
                validity = (not_after - not_before).days
                
                # 5. L·∫•y Issuer (ƒê∆°n v·ªã c·∫•p)
                issuer_components = dict(x509.get_issuer().get_components())
                # ∆Øu ti√™n l·∫•y Organization (O), n·∫øu kh√¥ng c√≥ l·∫•y Common Name (CN)
                issuer_name = issuer_components.get(b'O', b'Unknown').decode('utf-8', 'ignore')
                if issuer_name == 'Unknown':
                    issuer_name = issuer_components.get(b'CN', b'Unknown').decode('utf-8', 'ignore')
                
                # 6. Feature Cert_Too_New
                cert_too_new = 1 if 0 <= cert_age < 30 else 0
                
                return cert_age, validity, cert_too_new, issuer_name

    except Exception as e:
        # V·∫´n l·ªói th√¨ ch·ªãu thua (Web ch·∫øt ho·∫∑c kh√¥ng c√≥ SSL)
        return -1, -1, 0, "Unknown"

# --- H√ÄM X·ª¨ L√ù T·ª™NG D√íNG ---
def process_row(row):
    # Ch·ªâ ch·∫°y l·∫°i n·∫øu SSL ƒëang b·ªã l·ªói (-1)
    if row.get('Certificate_Age', -1) == -1:
        url = row['url']
        c_age, c_val, c_new, c_issuer = get_ssl_info_robust(url)
        
        row['Certificate_Age'] = c_age
        row['Certificate_Validity_Days'] = c_val
        row['Cert_Too_New'] = c_new
        
        # Check Trusted Issuer
        trusted_list = ['Google', 'Microsoft', 'DigiCert', 'Sectigo', 'GlobalSign', 'Amazon', 
                        'Apple', 'Entrust', 'GeoTrust', 'Thawte', 'GoDaddy', 'VeriSign', 
                        'GTS', "Let's Encrypt", 'Cloudflare']
        
        is_trusted = 0
        if c_issuer != "Unknown":
             if any(t.lower() in str(c_issuer).lower() for t in trusted_list):
                 is_trusted = 1
        row['Is_Trusted_Issuer'] = is_trusted
        
    return row

# --- MAIN ---
def main():
    print("üöÄ B·∫ÆT ƒê·∫¶U V√Å L·ªñI SSL (CH·∫æ ƒê·ªò AGGRESSIVE)...")
    
    try:
        df = pd.read_csv(INPUT_FILE)
        print(f"üìÇ ƒê√£ t·∫£i file: {len(df):,} d√≤ng.")
    except:
        print(f"‚ùå Kh√¥ng t√¨m th·∫•y file {INPUT_FILE}")
        return

    error_count = len(df[df['Certificate_Age'] == -1])
    print(f"‚ö†Ô∏è  S·ªë d√≤ng c·∫ßn s·ª≠a: {error_count:,}")
    
    data = df.to_dict('records')
    processed_count = 0
    success_count = 0
    
    print(f"‚è≥ ƒêang ch·∫°y l·∫°i SSL v·ªõi {MAX_WORKERS} lu·ªìng...")
    start_time = time.time()

    results = []
    with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        futures = {executor.submit(process_row, row): row for row in data}
        
        for future in concurrent.futures.as_completed(futures):
            res = future.result()
            results.append(res)
            processed_count += 1
            
            if res['Certificate_Age'] != -1:
                success_count += 1
            
            if processed_count % 100 == 0:
                sys.stdout.write(f"\r   ‚ñ∂ Ti·∫øn ƒë·ªô: {processed_count}/{len(df)} | ‚úÖ C·ª©u ƒë∆∞·ª£c: {success_count} d√≤ng")
                sys.stdout.flush()

    print(f"\n\n‚úÖ HO√ÄN T·∫§T! Th·ªùi gian: {time.time() - start_time:.1f}s")
    print(f"   - T·ªïng s·ªë d√≤ng s·ª≠a ƒë∆∞·ª£c: {success_count:,}")
    
    final_df = pd.DataFrame(results)
    
    # S·∫Øp x·∫øp c·ªôt
    cols = list(final_df.columns)
    if 'label' in cols:
        cols.append(cols.pop(cols.index('label')))
    final_df = final_df[cols]
    
    final_df.to_csv(OUTPUT_FILE, index=False)
    print(f"üíæ File m·ªõi ƒë√£ l∆∞u t·∫°i: {OUTPUT_FILE}")

if __name__ == "__main__":
    main()
