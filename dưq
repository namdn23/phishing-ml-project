import pandas as pd
import socket
import ssl
import concurrent.futures
import time
from urllib.parse import urlparse
from datetime import datetime
import sys

# --- C·∫§U H√åNH ---
INPUT_FILE = 'dataset_final_train.csv'       # File d·ªØ li·ªáu hi·ªán t·∫°i (ƒëang b·ªã l·ªói SSL)
OUTPUT_FILE = 'dataset_final_train_fixed.csv' # File k·∫øt qu·∫£ sau khi v√° l·ªói
MAX_WORKERS = 20                             # Gi·∫£m xu·ªëng 20 ƒë·ªÉ m·∫°ng ·ªïn ƒë·ªãnh h∆°n
TIMEOUT_SOCKET = 10                          # TƒÉng l√™n 10 gi√¢y ƒë·ªÉ ch·ªù ph·∫£n h·ªìi

# --- H√ÄM L·∫§Y SSL C·∫¢I TI·∫æN ---
def get_ssl_info_robust(url):
    try:
        # 1. X·ª≠ l√Ω URL ƒë·ªÉ l·∫•y hostname
        if not url.startswith(('http://', 'https://')):
            url = 'https://' + url # M·∫∑c ƒë·ªãnh th·ª≠ https tr∆∞·ªõc
        
        parsed = urlparse(url)
        domain = parsed.netloc
        
        # Lo·∫°i b·ªè port n·∫øu c√≥ (vd: example.com:8080)
        if ':' in domain:
            domain = domain.split(':')[0]
            
        if not domain: return -1, -1, "Unknown"

        # 2. T·∫°o Context SSL (Ch·∫•p nh·∫≠n c·∫£ cert l·ªói/h·∫øt h·∫°n)
        ctx = ssl.create_default_context()
        ctx.check_hostname = False
        ctx.verify_mode = ssl.CERT_NONE
        
        # 3. K·∫øt n·ªëi Socket (C√≥ x·ª≠ l√Ω Timeout)
        with socket.create_connection((domain, 443), timeout=TIMEOUT_SOCKET) as sock:
            with ctx.wrap_socket(sock, server_hostname=domain) as ssock:
                cert = ssock.getpeercert()
                
                # 4. T√≠nh to√°n ng√†y th√°ng
                not_before = datetime.strptime(cert['notBefore'], '%b %d %H:%M:%S %Y %Z')
                not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                now = datetime.now()
                
                cert_age = (now - not_before).days
                validity = (not_after - not_before).days
                
                # 5. L·∫•y Issuer
                issuer = "Unknown"
                if 'issuer' in cert:
                    for item in cert['issuer']:
                        for key, value in item:
                            if key in ['organizationName', 'commonName', 'O', 'CN']:
                                issuer = value
                                break
                        if issuer != "Unknown": break
                
                # 6. T√≠nh Feature "Cert_Too_New" lu√¥n
                # (Logic: 1 n·∫øu tu·ªïi ƒë·ªùi < 30 ng√†y, ng∆∞·ª£c l·∫°i 0)
                cert_too_new = 1 if 0 <= cert_age < 30 else 0
                
                return cert_age, validity, cert_too_new, issuer

    except Exception:
        # N·∫øu l·ªói (kh√¥ng c√≥ SSL, timeout, connection refused) -> Tr·∫£ v·ªÅ -1
        return -1, -1, 0, "Unknown"

# --- H√ÄM X·ª¨ L√ù T·ª™NG D√íNG ---
def process_row(row):
    # Ch·ªâ ch·∫°y l·∫°i n·∫øu SSL ƒëang b·ªã l·ªói (-1)
    if row.get('Certificate_Age', -1) == -1:
        url = row['url'] # L·∫•y URL t·ª´ c·ªôt 'url'
        c_age, c_val, c_new, c_issuer = get_ssl_info_robust(url)
        
        # C·∫≠p nh·∫≠t l·∫°i gi√° tr·ªã cho d√≤ng ƒë√≥
        row['Certificate_Age'] = c_age
        row['Certificate_Validity_Days'] = c_val
        row['Cert_Too_New'] = c_new
        
        # Is_Trusted_Issuer (T√°i t√≠nh to√°n)
        trusted_list = ['Google', 'Microsoft', 'DigiCert', 'Sectigo', 'GlobalSign', 'Amazon', 
                        'Apple', 'Entrust', 'GeoTrust', 'Thawte', 'GoDaddy', 'VeriSign', 
                        'GTS', "Let's Encrypt", 'Cloudflare']
        
        is_trusted = 0
        if c_issuer != "Unknown":
             if any(t.lower() in str(c_issuer).lower() for t in trusted_list):
                 is_trusted = 1
        row['Is_Trusted_Issuer'] = is_trusted
        
    return row

# --- MAIN ---
def main():
    print("üöÄ B·∫ÆT ƒê·∫¶U V√Å L·ªñI SSL CHO D·ªÆ LI·ªÜU...")
    
    try:
        df = pd.read_csv(INPUT_FILE)
        print(f"üìÇ ƒê√£ t·∫£i file: {len(df):,} d√≤ng.")
    except:
        print("‚ùå Kh√¥ng t√¨m th·∫•y file dataset_final_train.csv")
        return

    # L·ªçc ra nh·ªØng d√≤ng c·∫ßn s·ª≠a (ƒë·ªÉ ƒë·∫øm s·ªë l∆∞·ª£ng)
    error_count = len(df[df['Certificate_Age'] == -1])
    print(f"‚ö†Ô∏è  S·ªë d√≤ng b·ªã l·ªói SSL c·∫ßn s·ª≠a: {error_count:,}")
    
    data = df.to_dict('records')
    processed_count = 0
    success_count = 0
    
    print(f"‚è≥ ƒêang ch·∫°y l·∫°i SSL v·ªõi {MAX_WORKERS} lu·ªìng (Timeout {TIMEOUT_SOCKET}s)...")
    start_time = time.time()

    results = []
    with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        # Map x·ª≠ l√Ω t·ª´ng d√≤ng
        futures = {executor.submit(process_row, row): row for row in data}
        
        for future in concurrent.futures.as_completed(futures):
            res = future.result()
            results.append(res)
            processed_count += 1
            
            # Ki·ªÉm tra xem c√≥ l·∫•y ƒë∆∞·ª£c kh√¥ng (kh√°c -1)
            if res['Certificate_Age'] != -1:
                success_count += 1
            
            # In ti·∫øn ƒë·ªô
            if processed_count % 100 == 0:
                sys.stdout.write(f"\r   ‚ñ∂ Ti·∫øn ƒë·ªô: {processed_count}/{len(df)} | ‚úÖ S·ª≠a ƒë∆∞·ª£c: {success_count} d√≤ng")
                sys.stdout.flush()

    print(f"\n\n‚úÖ HO√ÄN T·∫§T! Th·ªùi gian: {time.time() - start_time:.1f}s")
    print(f"   - T·ªïng s·ªë d√≤ng s·ª≠a ƒë∆∞·ª£c: {success_count:,}")
    print(f"   - T·ªâ l·ªá th√†nh c√¥ng: {success_count/len(df)*100:.1f}%")
    
    # L∆∞u file m·ªõi
    final_df = pd.DataFrame(results)
    
    # S·∫Øp x·∫øp l·∫°i c·ªôt cho ƒë·∫πp (n·∫øu c·∫ßn)
    cols = list(final_df.columns)
    if 'label' in cols: # ƒê∆∞a label v·ªÅ cu·ªëi
        cols.append(cols.pop(cols.index('label')))
    final_df = final_df[cols]
    
    final_df.to_csv(OUTPUT_FILE, index=False)
    print(f"üíæ D·ªØ li·ªáu m·ªõi ƒë√£ l∆∞u t·∫°i: {OUTPUT_FILE}")
    print("üëâ B·∫°n h√£y d√πng file n√†y ƒë·ªÉ Train Model nh√©!")

if __name__ == "__main__":
    main()
