import pandas as pd
import numpy as np
import math
import re
import asyncio
import os
import requests
from urllib.parse import urlparse
from playwright.async_api import async_playwright
from concurrent.futures import ProcessPoolExecutor

# ================= CONFIGURATION =================
PHISHTANK_URL = "https://data.phishtank.com/data/online-valid.csv"
OUTPUT_FILE = "Phishing_Extra_Data_24F.csv"
NUM_PROCESSES = 6       # S·ªë l∆∞·ª£ng CPU core mu·ªën d√πng
TIMEOUT_MS = 40000      # 40 gi√¢y cho m·ªói trang
LIMIT_URLS = 15000      # S·ªë l∆∞·ª£ng URL Phishing mu·ªën l·∫•y th√™m

# ================= LOGIC TR√çCH XU·∫§T =================
def calculate_entropy(text):
    if not text or len(text) == 0: return 0
    prob = [float(text.count(c)) / len(text) for c in dict.fromkeys(list(text))]
    return -sum(p * math.log(p, 2) for p in prob)

async def get_features(page, url):
    try:
        # Truy c·∫≠p URL v·ªõi timeout
        await page.goto(url, timeout=TIMEOUT_MS, wait_until="domcontentloaded")
        await asyncio.sleep(2) # ƒê·ª£i JS render th√™m t√≠
        
        content = (await page.content()).lower()
        title = (await page.title()) or ""
        parsed = urlparse(url)
        domain = parsed.netloc.lower()
        visible_text = await page.inner_text("body")

        # 1. Nh√≥m ƒê·∫∑c tr∆∞ng Tƒ©nh (Static)
        digits = sum(c.isdigit() for c in url)
        is_https = 1 if url.startswith('https') else 0
        digit_ratio = digits / len(url) if len(url) > 0 else 0
        
        # 2. Nh√≥m ƒê·∫∑c tr∆∞ng N·ªôi dung (Content/Dynamic)
        domain_match = 1 if domain.split('.')[0] in title.lower() else 0
        has_social = 1 if any(s in content for s in ['facebook.com', 'twitter.com', 'instagram.com', 'linkedin']) else 0
        has_copyright = 1 if any(x in content for x in ['¬©', 'copyright', 'all rights reserved']) else 0
        has_desc = 1 if await page.query_selector('meta[name="description"]') else 0
        has_password = 1 if await page.query_selector('input[type="password"]') else 0
        has_submit = 1 if await page.query_selector('input[type="submit"], button[type="submit"]') else 0
        
        # Ki·ªÉm tra Form submit ra ngo√†i domain
        ext_form = 0
        forms = await page.query_selector_all('form')
        for form in forms:
            action = await form.get_attribute('action')
            if action and action.startswith('http') and domain not in action:
                ext_form = 1
                break

        # 3. Nh√≥m K·ªπ thu·∫≠t (Technical)
        iframes = await page.query_selector_all('iframe')
        hidden_iframe = 1 if await page.query_selector('iframe[style*="display:none"], iframe[width="0"], iframe[height="0"]') else 0
        
        return {
            'URL': url,
            'NoOfDegitsInURL': digits,
            'IsHTTPS': is_https,
            'DomainTitleMatchScore': domain_match,
            'HasDescription': has_desc,
            'HasExternalFormSubmit': ext_form,
            'HasSocialNet': has_social,
            'HasSubmitButton': has_submit,
            'HasPasswordField': has_password,
            'HasCopyrightInfo': has_copyright,
            'label': 1, # ƒêang c√†o phishing n√™n m·∫∑c ƒë·ªãnh l√† 1
            'V1_PHash_Distance': 0, # Feature n√†y c·∫ßn so s√°nh ·∫£nh, t·∫°m ƒë·ªÉ 0
            'V2_Layout_Similarity': 0, # T∆∞∆°ng t·ª±, ƒë·ªÉ 0
            'V6_JS_Entropy': calculate_entropy(content),
            'V7_Text_Readability_Score': len(visible_text.split()) / 500, # Normalize s∆° b·ªô
            'V8_Total_IFrames': len(iframes),
            'V9_Has_Hidden_IFrame': hidden_iframe,
            'V5_TLS_Issuer_Reputation': is_https, # Gi·∫£ ƒë·ªãnh ƒë∆°n gi·∫£n
            'V4_DNS_Volatility_Count': 0, # C·∫ßn DNS lookup, t·∫°m ƒë·ªÉ 0
            'Is_Top_1M_Domain': 0, # Phishing hi·∫øm khi n·∫±m trong top 1M
            'V22_IP_Subdomain_Pattern': 1 if re.match(r'\d+\.\d+\.\d+', domain) else 0,
            'V23_Entropy_Subdomain': calculate_entropy(domain.split('.')[0]),
            'Trust_Score': domain_match * is_https,
            'Digit_Ratio': digit_ratio
        }
    except Exception as e:
        return None

# ================= WORKER CH·∫†Y TRONG M·ªñI PROCESS =================
async def run_worker(urls, proc_id):
    results = []
    async with async_playwright() as p:
        # Kh·ªüi t·∫°o browser v·ªõi c√°c flag v∆∞·ª£t ch·∫∑n bot
        browser = await p.chromium.launch(headless=True, args=['--no-sandbox', '--disable-setuid-sandbox'])
        # Gi·∫£ l·∫≠p User-Agent x·ªãn
        context = await browser.new_context(
            user_agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36"
        )
        
        for i, url in enumerate(urls):
            page = await context.new_page()
            data = await get_features(page, url)
            if data:
                results.append(data)
                print(f"[Process {proc_id}] Success ({i+1}/{len(urls)}): {url[:40]}...")
            else:
                print(f"[Process {proc_id}] Failed: {url[:40]}...")
            await page.close()
            
        await browser.close()
    return results

def process_entry(urls, proc_id):
    return asyncio.run(run_worker(urls, proc_id))

# ================= MAIN EXECUTION =================
if __name__ == "__main__":
    # 1. T·∫£i URL t·ª´ PhishTank
    print("üì• ƒêang l·∫•y URL t·ª´ PhishTank...")
    try:
        raw_pt = pd.read_csv(PHISHTANK_URL)
        phish_urls = raw_pt['url'].head(LIMIT_URLS).tolist()
    except:
        print("‚ùå L·ªói t·∫£i CSV. Ki·ªÉm tra k·∫øt n·ªëi m·∫°ng!")
        exit()

    # 2. Chia vi·ªác cho c√°c Process
    chunks = np.array_split(phish_urls, NUM_PROCESSES)
    
    final_results = []
    print(f"üöÄ B·∫Øt ƒë·∫ßu tr√≠ch xu·∫•t v·ªõi {NUM_PROCESSES} lu·ªìng...")
    
    with ProcessPoolExecutor(max_workers=NUM_PROCESSES) as executor:
        futures = [executor.submit(process_entry, chunks[i].tolist(), i) for i in range(NUM_PROCESSES)]
        for f in futures:
            final_results.extend(f.result())

    # 3. L∆∞u k·∫øt qu·∫£
    df_new = pd.DataFrame(final_results)
    df_new.to_csv(OUTPUT_FILE, index=False)
    print(f"üèÅ Xong! ƒê√£ thu ho·∫°ch ƒë∆∞·ª£c {len(df_new)} m·∫´u Phishing s·∫°ch v√†o {OUTPUT_FILE}")
